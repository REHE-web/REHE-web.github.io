<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><title>面向服务的软件工程复习 | REHE's Blog</title><meta name="author" content="REHE"><meta name="copyright" content="REHE"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="简答题服务和制造 服务和制造的区别？相似和不同之处？什么是制造，什么是服务？ 为什么需要面向服务的泛型？  服务和制造的区别 服务客户和服务提供者双向交互 制造模式中用户和产品提供者的交互是单向的  服务模式（Service Mode）和制造模式（Manufacturing Mode）的最大差异在于：服务模式的产物是服务（Service），而制造模式的产物是货物（Goods）。服务是无形的、挥发的"><meta property="og:type" content="article"><meta property="og:title" content="面向服务的软件工程复习"><meta property="og:url" content="http://example.com/2023/04/08/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/index.html"><meta property="og:site_name" content="REHE&#39;s Blog"><meta property="og:description" content="简答题服务和制造 服务和制造的区别？相似和不同之处？什么是制造，什么是服务？ 为什么需要面向服务的泛型？  服务和制造的区别 服务客户和服务提供者双向交互 制造模式中用户和产品提供者的交互是单向的  服务模式（Service Mode）和制造模式（Manufacturing Mode）的最大差异在于：服务模式的产物是服务（Service），而制造模式的产物是货物（Goods）。服务是无形的、挥发的"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="http://example.com/img/flower.jpg"><meta property="article:published_time" content="2023-04-08T14:20:00.000Z"><meta property="article:modified_time" content="2023-04-08T14:20:00.000Z"><meta property="article:author" content="REHE"><meta property="article:tag" content="复习"><meta property="article:tag" content="SOA"><meta property="article:tag" content="面向服务"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="http://example.com/img/flower.jpg"><link rel="shortcut icon" href="/img/mountain_icon.ico"><link rel="canonical" href="http://example.com/2023/04/08/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="/css/fonts.css" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:void 0,translate:void 0,noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:200},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!0,post:!0},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:{limitCount:50,languages:{author:"作者: REHE",link:"链接: ",source:"来源: REHE's Blog",info:"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!1,isAnchor:!1,percent:{toc:!0,rightside:!0}}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"面向服务的软件工程复习",isPost:!0,isHome:!1,isHighlightShrink:!1,isToc:!0,postUpdate:"2023-04-08 22:20:00"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise(((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)})),e.getCSS=(e,t=!1)=>new Promise(((o,n)=>{const a=document.createElement("link");a.rel="stylesheet",a.href=e,t&&(a.id=t),a.onerror=n,a.onload=a.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(a.onload=a.onreadystatechange=null,o())},document.head.appendChild(a)})),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="/css/background.css"><link rel="stylesheet" href="/css/fonts.css"><link rel="stylesheet" href="/css/loading.css"><link rel="stylesheet" href="/css/progress_bar.css"><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><div class="loading-img"></div><div class="loading-image-dot"></div></div></div><script>const preloader={endLoading:()=>{document.body.style.overflow="auto",document.getElementById("loading-box").classList.add("loaded")},initLoading:()=>{document.body.style.overflow="",document.getElementById("loading-box").classList.remove("loaded")}};window.addEventListener("load",(()=>{preloader.endLoading()}))</script><link rel="stylesheet" href="/css/progress_bar.css"><script src="https://cdn.jsdelivr.net/npm/pace-js/pace.min.js"></script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.png" onerror='onerror=null,src="/img/friend_404.gif"' alt="avatar"></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-torii-gate"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-list-ul"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-blog"></i> <span>日志</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url('/img/flower.jpg')"><nav id="nav"><span id="blog-info"><a href="/" title="REHE's Blog"><span class="site-name">REHE's Blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-torii-gate"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-list-ul"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page" href="/blog/"><i class="fa-fw fas fa-blog"></i> <span>日志</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">面向服务的软件工程复习</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-04-08T14:20:00.000Z" title="发表于 2023-04-08 22:20:00">2023-04-08</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-04-08T14:20:00.000Z" title="更新于 2023-04-08 22:20:00">2023-04-08</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%A4%8D%E4%B9%A0%E8%B5%84%E6%96%99/">复习资料</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">7.1k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="面向服务的软件工程复习"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="简答题"><a href="#简答题" class="headerlink" title="简答题"></a>简答题</h1><h2 id="服务和制造"><a href="#服务和制造" class="headerlink" title="服务和制造"></a>服务和制造</h2><ul><li>服务和制造的区别？相似和不同之处？什么是制造，什么是服务？</li><li>为什么需要面向服务的泛型？</li></ul><h3 id="服务和制造的区别"><a href="#服务和制造的区别" class="headerlink" title="服务和制造的区别"></a>服务和制造的区别</h3><ul><li>服务客户和服务提供者双向交互</li><li>制造模式中用户和产品提供者的交互是单向的</li></ul><p>服务模式（Service Mode）和制造模式（Manufacturing Mode）的最大差异在于：服务模式的产物是服务（Service），而制造模式的产物是货物（Goods）。服务是无形的、挥发的，并可能以消费者参与的方式定制化生产；而货物是有型的、可存储的，消费者不直接参与货物的生产过程。</p><h3 id="为什么需要面向服务的泛型"><a href="#为什么需要面向服务的泛型" class="headerlink" title="为什么需要面向服务的泛型"></a>为什么需要面向服务的泛型</h3><ol><li>面向服务的快速发展导致单个组织<strong>无法独立提供全套服务</strong>，提供的有限服务也<strong>无法被广泛运用</strong>；已存在的服务并不能很好地被<strong>发现</strong>和<strong>调用</strong>，也导致大量冗余服务。</li><li>另一方面：原先的服务系统是复杂、脆弱、特殊的，<strong>从上层业务看</strong>，无法灵活应对实际业务的变更；<strong>从底层实现看</strong>，也无法及时应对底层技术的更新、或者新增的功能。</li><li>因此构建服务生态系统，运用面向服务的分析和设计原则，使得产生的服务具有良好的可发现性和可复用性，同时能灵活应对业务领域和技术领域的变更。</li></ol><h2 id="SOAP"><a href="#SOAP" class="headerlink" title="SOAP"></a>SOAP</h2><ul><li>SOAP 包的主要构成，如何配合在一起完成消息交互</li><li>解决问题的时候如何去处理（两种主流的 SOAP 的利用方式）</li><li>协作完成任务的例子</li></ul><h3 id="SOAP-包结构"><a href="#SOAP-包结构" class="headerlink" title="SOAP 包结构"></a>SOAP 包结构</h3><p>SOAP 包本质是⼀个 XML 文档，包含下列元素：</p><ul><li><p>Envelope元素（SOAP 声明）</p><ul><li>必需元素，根元素，标识此 XML ⽂档为⼀条 SOAP 消息</li><li>可以包含命名空间和声明额外的属性。如果出现额外属性，则必须使⽤命名空间修饰</li></ul></li><li><p>Header 元素（应用相关的控制数据）</p><ul><li>可选元素，有关 SOAP 消息的应用程序专用信息（比如认证、支付等）</li></ul></li><li><p>Body 元素（消息容器）</p><ul><li>必需元素，包含所有的调用和响应信息</li></ul></li><li><p>Fault 元素（出错消息）</p><ul><li>可选元素，提供有关在处理此消息所发生错误的信息</li></ul></li></ul><p><img src="/img/SOAP.png" alt="image-20230408203251070"></p><h3 id="处理模型"><a href="#处理模型" class="headerlink" title="处理模型"></a>处理模型</h3><ol><li>用 XML 打包请求：<ol><li>将接口名作为根节点</li><li>方法和参数作为节点</li></ol></li><li>将请求发给服务器：<ol><li>不创建自己的 TCP&#x2F;IP 信息，利用 HTTP</li><li>将请求封装成 HTTP POST 请求格式发出</li></ol></li><li>服务器收到请求，解码 XML，处理请求，以 XML 格式返回响应<ol><li>与请求比较，方法的节点名字变为请求的方法名后缀 Response</li><li>客户程序自己调用了哪个方法，根据方法名后缀 Response 寻找调用方法的返回值</li></ol></li></ol><h3 id="处理模式"><a href="#处理模式" class="headerlink" title="处理模式"></a>处理模式</h3><p><img src="/img/%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F.png" alt="image-20230408203432742"></p><h3 id="交互模式"><a href="#交互模式" class="headerlink" title="交互模式"></a>交互模式</h3><ol><li>远程过程调用模式（RPC 模式）<ul><li>⼀种同步请求&#x2F;响应交互的方法</li><li>发出请求后会⼀直等待响应</li></ul></li><li>面向文档模式<ul><li>⼀种异步交互的⽅法</li><li>发送⼀个复杂的 XML 文档，然后等待通知，结果会在处理后发送回来</li></ul></li></ol><h2 id="WSDL"><a href="#WSDL" class="headerlink" title="WSDL"></a>WSDL</h2><ul><li>WSDL 的核心</li><li>每一个部件具体做什么</li></ul><h3 id="WSDL-的核心"><a href="#WSDL-的核心" class="headerlink" title="WSDL 的核心"></a>WSDL 的核心</h3><p>WSDL（Web Services Description Language）是一种XML格式的语言，用于描述Web服务的接口、操作、消息、地址等信息。WSDL的核心是描述Web服务接口的抽象部分和具体部分。</p><h3 id="具体部件的用途"><a href="#具体部件的用途" class="headerlink" title="具体部件的用途"></a>具体部件的用途</h3><p>WSDL（Web Services Description Language）2.0 以 description 元素为根节点</p><p>import、include：拼装不同部门&#x2F;组织定义的文档，形成完整的 WSDL 语义</p><ol><li><p>抽象部分：</p><ol><li><p>Types：使用到的数据结构或者叫数据格式范式，独立于语言和平台</p></li><li><p>Interface：operation 的集合即服务能力的集合，描述服务能力</p><p>operation：input、output、infault、outfault</p></li></ol></li><li><p>具体部分：</p><ol><li><p>Binding：特定端口类型的具体协议和数据格式规范的绑定</p></li><li><p>Service：对服务整体的抽象，包含若干个 endpoint</p><p>endpoint：将绑定与当前地址关联</p></li></ol></li></ol><h2 id="服务的泛型"><a href="#服务的泛型" class="headerlink" title="服务的泛型"></a>服务的泛型</h2><ul><li>面向对象和面向服务的异同</li></ul><h3 id="面向对象-VS-面向服务"><a href="#面向对象-VS-面向服务" class="headerlink" title="面向对象 VS 面向服务"></a>面向对象 VS 面向服务</h3><table><thead><tr><th>特点</th><th>面向对象的计算</th><th>面向服务的计算</th></tr></thead><tbody><tr><td>方法论</td><td>通过定义紧耦合的类来进行应用开发；应用架构为基于继承关系的层次式架构；从构造函数——通过类或模型——到系统设计</td><td>通过定义松耦合的服务来进行应用开发，并将服务组装成可执行的应用；从系统模型到服务模块，从服务抽象定义到服务实现绑定；通过搜索获得可用的服务实现</td></tr><tr><td>抽象和协作层次</td><td>往往由一个团队来负责应用的开发，并负责整个生命周期；开发者必须了解应用领域的编程知识</td><td>开发任务由三个独立方承担：应用程序开发者，服务提供方和服务代理；其中，应用程序开发者需要了解应用逻辑，但不需要了解具体的服务是如何实现的；服务提供者需要编程能力，但不必了解使用服务的应用</td></tr><tr><td>代码共享和复用</td><td>代码复用通过类成员的继承和库函数加以实现。其中库函数在编译时引入，且往往是平台相关的</td><td>代码在服务层次复用。服务使用标准的结构，并发布在 internet 库中。服务是平台无关的，且能够被查找并远程调用。服务代理支持系统的服务共享</td></tr><tr><td>动态绑定和重新组合</td><td>在运行时将名称和方法进行关联。方法必须在应用部署前链接到可执行的代码</td><td>在运行时将服务调用和服务进行绑定。可以在应用部署后，再进行服务选定。这一特色使得应用可以在运行时重组</td></tr><tr><td>重组</td><td>多在设计时决定导入的组件</td><td>可以动态改变应用系统中服务的组合关系，以及服务定义与服务实现之间的绑定关系，即实现动态地添加、修改、删除各个服务节点</td></tr><tr><td>组件通讯和接口</td><td>与平台和语言有关，例如 c++ 程序难以直接和 java 程序通信</td><td>与平台和语言无关。组件间通过标准协议通信，如 XML，WSDL 和 SOAP</td></tr><tr><td>系统维护</td><td>用户需要时常升级软件，且在执行升级时，应用必须停止</td><td>通过互联网升级系统，因为服务多运行在远程服务器上，用户通过互联网进行访问。维护对用户透明</td></tr><tr><td>可靠性</td><td>在设计时决定可靠性的方法</td><td>对于服务提供者，每个服务相对简单，更加可靠。对于应用程序存在多个满足同一需求的服务，可通过将故障服务的节点断开并重新绑定到备选服务节点上，获得不间断的应用系统</td></tr><tr><td>软件拥有</td><td>软件作为产品销售，为用户所拥有</td><td>软件存在并执行于独立的服务提供商的设备上，用户按照每次对服务使用付费，而不是按照软件产品付费</td></tr></tbody></table><h2 id="八大设计原则"><a href="#八大设计原则" class="headerlink" title="八大设计原则"></a>八大设计原则</h2><ul><li>八个设计原则互相之间的关系</li></ul><h3 id="标准化服务合约"><a href="#标准化服务合约" class="headerlink" title="标准化服务合约"></a>标准化服务合约</h3><ol><li>标准化服务合约与服务松散耦合<ul><li>消费者和服务之间存在对服务合约中技术接口的依赖<ul><li>技术服务合约越详细，越内容丰富，消费者和服务之间的依赖关系越强</li><li>两个服务之间所达到的松散耦合程度直接与在服务合约中的依赖关系数量相关</li></ul></li><li>标准化的合约将会有助于提高服务之间的一致性和耦合质量(quality of coupling)</li></ul></li><li>标准化服务合约与服务抽象<ul><li>服务抽象原则要求简化合约<ul><li>非核心信息都被隐藏</li></ul></li><li>服务合约的设计决定了抽象的程度<ul><li>在合约中的内容越仔细，服务中被抽象的信息就越少</li></ul></li></ul></li><li>标准化服务合约与服务可复用性<ul><li>服务可复用性原则常常侧重于服务封装的逻辑是否足够一般和通用</li><li>可复用方案逻辑与数据交换之间的关系最终要由服务合约是如何设计的来决定</li><li>服务合约越是通用、灵活和可扩展，服务的长远复用潜力就越大</li></ul></li><li>标准化服务合约与服务可发现性<ul><li>服务合约越是得到一致的标注和结构化，对于那些需要使用它们的人来说就越是可以预测的</li><li>服务合约越是标准化，元信息(meta information) 的技术接口细节提供得越是充分，服务的可发现性就越高</li></ul></li><li>标准化服务合约与服务可组合性<ul><li>服务的可组合性需求常常与服务合约表达其能力的粒度有关</li><li>粗粒度的操作拥有更高的效率，但常常不适应于需要参与到更大规模组合中的服务</li></ul></li></ol><h3 id="服务松散耦合"><a href="#服务松散耦合" class="headerlink" title="服务松散耦合"></a>服务松散耦合</h3><ol><li>服务松散耦合与标准化服务合约<ul><li>松散耦合鼓励调节技术合约内容的数量和复杂度，从而最小化消费者依赖需求、最大化服务所有者的自由度，在不影响现有消费者的情况下随着时间演化和改变服务</li></ul></li><li>服务松散耦合与服务抽象<ul><li>创建更低耦合的消费者关系，明确地要求应用良好定义的功能和技术抽象级别</li></ul></li><li>服务松散耦合与服务可复用性<ul><li>减少依赖关系可以使服务更容易被组合、演化甚至扩充以支持不断变化的业务需求和方向</li></ul></li><li>服务松散耦合与服务自治<ul><li>减少消极耦合类型的程度，会为运行时和设计时的更高自治级别提供支持</li><li>服务消费者具有越多的跨服务依赖，它所具有的自主权就越少（服务消费者可能同时担任复合服务中的服务协调者）</li></ul></li><li>服务松散耦合与服务可发现性<ul><li>服务松散耦合有助于元数据的调节</li></ul></li><li>服务松散耦合与服务可组合性<ul><li>在服务组合中，避免消极形式的耦合<ul><li>“合约-逻辑”耦合 如果服务合约是自动生成的，就很有可能在被其他服务使用时不符合标准。因此需要在它和其他组成成员之间进行转换</li><li>“合约-技术”耦合 如果同一个组合中的不同部分同时使用开放与专用服务技术，就会需要在本地实现技术转化层</li><li>“合约-实现”耦合 当一个服务合约与底层实现特性之间产生耦合时，就会最终把这些性质强加到作为一个整体的组合之上</li></ul></li></ul></li></ol><h3 id="服务抽象"><a href="#服务抽象" class="headerlink" title="服务抽象"></a>服务抽象</h3><ol><li>服务抽象与标准化服务合约<ul><li>服务抽象出来并对外界可用的信息就是服务合约，服务抽象原则的应用影响到服务合约</li><li>服务合约的设计标准也会影响到功能、技术和逻辑抽象的等级</li></ul></li><li>服务抽象与服务松散耦合<ul><li>抽象的程度对可能耦合的程度有直接的关系</li><li>少量的高度详细的技术接口约束会导致比大量含糊或开放的数据约束更多的紧密耦合需求<ul><li>耦合的程度一般由被抽象的信息数量和信息本身的属性的组合来决定</li><li>最终由服务合约的粒度加以体现</li></ul></li></ul></li><li>服务抽象与其他原则<ul><li>其他的服务设计原则，如服务可复用性、服务可组合性和服务可发现性等原则都鼓励创建更多的、关于服务的元信息</li><li>而服务的抽象原则要求在发布这些元信息前评估其必要程度</li></ul></li></ol><h3 id="服务可复用性"><a href="#服务可复用性" class="headerlink" title="服务可复用性"></a>服务可复用性</h3><ol><li>服务可复用性与标准化服务合约<ul><li>可复用的服务需要足够的灵活性来支持带有不同交互需求的消费者</li><li>导致降低合约验证约束（尤其是那些易变的）的设计标准</li></ul></li><li>服务可复用性与服务抽象<ul><li>合约的自描述性与简洁之间的平衡</li><li>元信息的抽象程度反映这一平衡</li></ul></li><li>服务可复用性与服务松散耦合<ul><li>一个服务的依赖需求越小，复用它就越简单</li><li>当追求服务逻辑的可复用性时，总是有一种减少服务合约约束的趋势</li></ul></li><li>服务可复用性与其他原则<ul><li>服务自治<ul><li>自治是对可复用服务潜在高性能和并行使用的保证</li></ul></li><li>服务无状态<ul><li>通过最小化状态管理责任，提高一个服务的可用性，从而提高有效扩展的能力</li></ul></li><li>服务可发现性<ul><li>可复用服务必需可发现、可解释</li></ul></li><li>服务可组合性<ul><li>可组合是复用的一种形式，可复用潜能越大，服务被反复组装的机会就越大</li></ul></li></ul></li></ol><h3 id="服务自治"><a href="#服务自治" class="headerlink" title="服务自治"></a>服务自治</h3><ol><li>服务自治与标准化服务合约<ul><li>服务合约自治直接与服务合约紧密相连</li><li>规范化的考虑会影响到合约如何形成，以及如何与其他服务协调</li><li>在服务合约上有越大的控制权，服务合约能被更好地定制和标准化，越能够确保底层实现可以在遵循既定自治级别的前提下，被独立设计</li></ul></li><li>服务自治与服务松散耦合<ul><li>由于同样期望将服务之间的依赖最小化，服务自治在很大程度上支持服务松散耦合原则<ul><li>积极耦合会直接导致设计时自治的增加；设计时自治的增加，又能更好地增强和优化服务的实现，从而支持运行时的自治</li></ul></li></ul></li><li>服务自治与服务抽象<ul><li>将一个服务的自治级别作为整个服务合约的一部分来发布</li><li>服务自治的信息是服务质量信息抽象的一个例子</li></ul></li><li>服务自治与服务可复用性<ul><li>自治的增加提高了一个服务的复用潜力</li><li>通过增强服务的可靠性和提高服务行为的可预测性，其逻辑可以更加容易地适应多个服务消费者的需求</li><li>更好地支持服务运行环境的演化，从而应对复用所带来的并发要求</li></ul></li><li>服务自治与服务无状态性<ul><li>实现高级别的服务自治可以直接支持服务无状态性程度的增加</li></ul></li><li>服务自治与服务可组合性<ul><li>服务组合的整体自治性取决于它的所有组成成员自身的自治性</li><li>服务有越好的可靠性和可预侧性就越能组成更高效的大型服务组合</li></ul></li></ol><h3 id="服务无状态性"><a href="#服务无状态性" class="headerlink" title="服务无状态性"></a>服务无状态性</h3><ol><li>服务无状态性与服务可复用性<ul><li>减少活动相关逻辑使一个服务变得更加无关（而无关服务具有更好的可复用性）</li><li>提高服务的可扩展性和可用性使得它们可以在更多的服务组合中被更多的服务消费者复用</li></ul></li><li>服务无状态性与服务自治<ul><li>状态信息的本质通常是特定于一个给定的活动或者业务流程的，通过在服务边界外改变状态管理机制和流程的职责，就可以降低服务逻辑依赖于更大的业务任务的可能性。这使得服务能够更加自给自足，并且能够被定位成技术环境的一个独立部分，因而直接增加其整体自治性</li><li>另一方面，由环境架构所提供的状态管理延迟选项可要求服务形成在其边界外的一个直接依赖。这种类型的外部实现耦合会影响到一个服务的整体自治</li></ul></li></ol><h3 id="服务可发现性"><a href="#服务可发现性" class="headerlink" title="服务可发现性"></a>服务可发现性</h3><ol><li>服务可发现性与标准化服务合约<ul><li>使服务更加容易可发现和可解释会影响服务合约的内容</li><li>服务可发现性会直接地影响功能表达设计标准的确定</li></ul></li><li>服务可发现性与服务抽象<ul><li>服务抽象的原则需要减少合约当中所发布的信息数量；服务可发现性则要求提供更多的信息；两者之间需要取得平衡</li><li>一旦实现了可发现性和抽象之间的适当的平衡，那么随后实现的服务的可发现性将基于那些已发布的（而不是被抽象的）元信息</li></ul></li><li>服务可发现性与服务可复用性<ul><li>强调服务可发现性的主要目的是支持服务可复用性</li><li>当表述可复用功能时，应当应用可发现性相关的设计标准，以保证能通过实际的技术合约把服务的目的和能力尽可能清楚地表述出来</li></ul></li><li>服务可发现性与服务可组合性<ul><li>潜在的组合成员应当容易定位和识别，以避免在无意间创建冗余的服务逻辑</li><li>当服务组合为了适应上层业务流程的变化或者为了增加整体的业务需求实现而发生演变时，需要查找从组合的原始版本创建以来，新加入的服务和功能</li></ul></li></ol><h3 id="服务可组合性"><a href="#服务可组合性" class="headerlink" title="服务可组合性"></a>服务可组合性</h3><ol><li>服务可组合性与标准化服务合约<ul><li>服务可组合性的应用强调服务间需要一致的合约标准</li><li>由服务可组合性原则引起的考虑可以用来帮助形成服务合约设计标准，以便支持特定于组合（尤其是复杂的组合）的需求。</li></ul></li><li>服务可组合性与服务松散耦合<ul><li>服务所具有的依赖关系会造成一些根本性的约束，直接制约服务能够达到的可组合性级别</li></ul></li><li>服务可组合性与服务抽象<ul><li><img src="/img/%E6%9C%8D%E5%8A%A1%E5%8F%AF%E7%BB%84%E5%90%88%E6%80%A7%E4%B8%8E%E6%9C%8D%E5%8A%A1%E6%8A%BD%E8%B1%A1.png" alt="image-20230408220350993"></li><li>当抽象化被应用到隐藏复杂的组合的程度时，对这些组合有效和可靠地执行的要求被大大放大了。作为回报，组合所有者对如何发展组合配置获得了更大的控制权。</li></ul></li><li>服务可组合性与服务可复用性<ul><li>当一个成熟的服务库存建立起来的时候，服务组合就成为最常用的服务复用方式<ul><li>可复用但不可组合（参与多个点对点活动）</li><li>可组合但不可复用（很高的“服务-消费者”耦合）</li></ul></li></ul></li><li>服务可组合性与服务自治<ul><li>这两个原则之间是“整体-部分”的关系</li><li>控制器服务在组合其他服务时需要牺牲其自治性（等价于对所有涉及的服务组合成员的自治性的综合度量结果）</li><li>服务自治性的提高有助于产生高效的组合成员</li></ul></li><li>服务可组合性与服务无状态性<ul><li>尽可能地减轻每个组合成员在状态管理方面的责任，可以更精细、更优化地执行整体的组合实例</li><li>为了能够在同一个服务库存中重复地装配出高效的服务组合，服务之间需要能够通过一致并且有效的方式共享状态数据</li></ul></li><li>服务可组合性与服务可发现性<ul><li>作为组合控制器的服务能力可以负责描述它所封装的整个组合逻辑，并达到服务抽象原则所允许的任意程度</li></ul></li></ol><h1 id="综合题"><a href="#综合题" class="headerlink" title="综合题"></a>综合题</h1><h2 id="Web-Service"><a href="#Web-Service" class="headerlink" title="Web Service"></a>Web Service</h2><ul><li>试结合相关协议和框架，描述一个 web service 从创建开始到被最终服务消费者调用的全过程对服务的建模、查询和调用的全过程。</li></ul><h3 id="服务的建模"><a href="#服务的建模" class="headerlink" title="服务的建模"></a>服务的建模</h3><p>XML（Namespace、XML Schema）、SOAP、WSDL</p><ul><li>XML 定义了 web 服务中的消息交换格式，使用 XML Schema 定义不同的数据结构，引入 Namespace 使得 XML、XML Schema 中的元素和属性全球唯一且全球共享；</li><li>SOAP 提供了一种标准的方法，使得运行在不同平台、使用不同的技术和编程语言的应用程序可以相互进行通信，服务的发布、查找、调用，都通过 SOAP 传递的 XML 消息。</li><li>WSDL 对服务能力、服务中使用的数据结构以及传输绑定给出定义和描述；提供了一种基于 XML 的标准接口定义语言&#x2F;服务能力定义语言，用以在服务的提供者&#x2F;调用者&#x2F;服务注册之间，交换必要的有关的 web service 的信息</li></ul><p>对于大多数服务，用以上三个协议和框架可以完成建模；对于一些更为复杂的服务，如复合服务或者是带有非功能性需求的服务，还需要用到其他协议和框架完成建模。</p><ul><li>BPEL 定义多个服务间如何交互和合作，从而将一组现有的服务根据业务流程构建起来，实现业务服务。</li><li>WS-Policy 可以实现一些非功能性需求，如信息加密，权限验证等。</li></ul><p>建模完成后，服务提供者，通过 UDDI 或者 WSIL 将服务发布出去。其中，UDDI 利用分页机制，让服务得到最大可能的复用和共享范围；WSIL 使用树形连接结构，适用于企业既定的业务。</p><h3 id="服务的查询"><a href="#服务的查询" class="headerlink" title="服务的查询"></a>服务的查询</h3><ol><li>消费者程序发送 SOAP 信息给服务注册，描述自己需要的服务；</li><li>服务注册查询注册表，通过 WSDL 服务合约找到一系列符合条件的服务；</li><li>服务注册将查询到的 WSDL 通过 SOAP 发送给消费者程序，让消费者程序从中选择可用的服务；</li><li>或者服务注册自动化筛选出当前最符合消费者程序要求的服务，通知消费者程序。</li></ol><h3 id="服务的调用"><a href="#服务的调用" class="headerlink" title="服务的调用"></a>服务的调用</h3><ol><li>消费者程序根据 WSDL 中提供的服务位置进行调用；</li><li>其中，消费者和提供者基于 WSDL 中约定的接口进行消息的发送和接收；</li><li>另一方面，当前服务可能同时被多个消费者程序使用，创建了一系列服务实例，WS-Addressing 提供了相应的机制，确保服务消费者能在实例池中找到特定的实例并与之通信；</li><li>另一方面，由于创建的实例是有状态的，利用 WSRF 对状态数据进行存取，进行状态管理，提高资源利用率。</li></ol><h2 id="服务分析和服务设计"><a href="#服务分析和服务设计" class="headerlink" title="服务分析和服务设计"></a>服务分析和服务设计</h2><ul><li>以电信企业为应⽤背景，举例描述服务分析和服务设计的过程。 并结合⾯向服务的设计原则（标准化服务合约、服务松散耦合、服 务抽象、服务可复⽤性、服务⾃治、服务⽆状态性、服务可发现性、 服务可组合性），讨论“schema集中化”“合约集中化”“逻辑集中化” 在设计过程中的应⽤</li></ul><h3 id="服务分析流程"><a href="#服务分析流程" class="headerlink" title="服务分析流程"></a>服务分析流程</h3><p>面向服务分析的目标是讨论需要构建哪些服务，每个服务应该封装哪些逻辑。分析的核心是业务服务：</p><ol><li>进行文档化的需求描述，定义流程自动化需求，作为服务候选建模的依据；由于电信企业发展比较完善，可以直接使用之前的需求文档分析</li><li>对现有的自动化系统进行分析、识别；分析企业正在使用的系统具有的功能</li><li>对服务候选建模，识别服务操作候选，并将其分组</li></ol><p>在面向服务分析流程中，需要考虑服务可复用性、服务自治和服务的可发现性</p><ul><li>可复用性：在服务建模中，需要：精化已有的服务能力候选，使其更加一般化和可复用；定义额外的服务能力候选，这些能力是在构成服务建模过程的基础的业务流程自动化所需之外的</li><li>自治：对已有自动化系统收集得到的消息，会影响服务系统所能达到的自治级别；比如根据信息决定保留遗留系统，那么达到共享自治，独立开发的可能达到逻辑自治或完全自治</li><li>可发现性：从服务生命周期开始，尤其是在产生服务操作候选时，需要以统一的方式，记录所有元数据；在服务建模过程中，业务和技术专家需要一起合作，建立服务候选</li></ul><h3 id="服务设计流程"><a href="#服务设计流程" class="headerlink" title="服务设计流程"></a>服务设计流程</h3><p>服务设计过程，是从服务候选（逻辑）派生出具体的服务设计（物理），然后装配到实现业务流程的抽象组合中。</p><ol><li>组合 SOA：选择编排、业务、应用服务层中的哪些进行实现，定义核心的 SOA 标准，选择 SOA 扩展（WS-*协议）</li><li>根据业务层级，分别设计以实体为核心的业务服务，应用服务，以任务为核心的业务服务</li><li>设计面向服务业务过程，组合服务构建出业务流程</li></ol><h3 id="schema-集中化"><a href="#schema-集中化" class="headerlink" title="schema 集中化"></a>schema 集中化</h3><p>传统的做法是在订购服务、退订服务中使用不同的套餐数据结构，而按照标准化服务合约，所有使用的数据结构都应该被单独定义、管理，与具体的操作流程无关。</p><p>采用 schema 集中化的设计模式，将电信企业划分为多个分离的领域（部门），每个领域都可以被独立地进行标准化和治理，每个领域定义和管理自己的 schema，作为整个服务系统的基本数据结构；在不同的服务中，使用这些 schema，避免了频繁且不必要的数据转换；在必要的情况下，可以利用这些 schema 定义新的数据结构</p><h3 id="合约集中化"><a href="#合约集中化" class="headerlink" title="合约集中化"></a>合约集中化</h3><p>为了保证服务松散耦合，避免消极耦合，采用合约集中化，<strong>将对服务的访问严格控制在合约内</strong>：</p><ol><li>所有的合约应该被集中管理，拥有一致的设计原则和设计目标</li><li>在服务生态中，任何情况都不可以绕开合约去访问具体内容</li></ol><p>服务抽象&amp;服务可发现性：设计服务暴露的信息</p><p>服务抽象：技术信息、功能、程序逻辑、服务质量抽象</p><p>服务抽象出来并对外界可用的信息就是服务合约，服务合约的设计标准会影响到其他</p><h3 id="逻辑集中化"><a href="#逻辑集中化" class="headerlink" title="逻辑集中化"></a>逻辑集中化</h3><p>为了实现服务可复用性，让消费者程序只调用指定的服务，要建立服务库存，在规范的服务库存中，每个服务代表了一个独特的功能域，这就要求服务边界之间没有重叠。</p><p>设置专家管理服务库存，应用开发人员不能直接往服务库存中增改需要的服务，只能请求当前服务库存管理人员进行审查，做出恰当的决策</p><p>同时，服务可发现性是实现服务可复用的前提，服务自治是可复用服务潜在高性能和并行使用的保证；无状态性能提高服务的可用性</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="http://example.com">REHE</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="http://example.com/2023/04/08/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/">http://example.com/2023/04/08/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">REHE's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E5%A4%8D%E4%B9%A0/">复习</a><a class="post-meta__tags" href="/tags/SOA/">SOA</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1/">面向服务</a></div><div class="post_share"><div class="social-share" data-image="/img/flower.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/06/19/SOA%E5%A4%8D%E4%B9%A0/" title="SOA复习"><img class="cover" src="/img/SAO.jpg" onerror='onerror=null,src="/img/404.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SOA复习</div></div></a></div><div class="next-post pull-right"><a href="/2023/04/08/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%8D%E4%B9%A0/" title="服务端开发复习"><img class="cover" src="/img/fuwu.png" onerror='onerror=null,src="/img/404.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">服务端开发复习</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2023/06/19/SOA%E5%A4%8D%E4%B9%A0/" title="SOA复习"><img class="cover" src="/img/SAO.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-06-19</div><div class="title">SOA复习</div></div></a></div><div><a href="/2023/04/08/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%8D%E4%B9%A0/" title="服务端开发复习"><img class="cover" src="/img/fuwu.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2023-04-08</div><div class="title">服务端开发复习</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.png" onerror='this.onerror=null,this.src="/img/friend_404.gif"' alt="avatar"></div><div class="author-info__name">REHE</div><div class="author-info__description">诗酒趁年华</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">4</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">5</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">2</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/REHE-web"><i class="fab fa-github"></i><span>GitHub</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/REHE-web" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:rehe_jiang@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AE%80%E7%AD%94%E9%A2%98"><span class="toc-number">1.</span> <span class="toc-text">简答题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%88%B6%E9%80%A0"><span class="toc-number">1.1.</span> <span class="toc-text">服务和制造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%92%8C%E5%88%B6%E9%80%A0%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">1.1.1.</span> <span class="toc-text">服务和制造的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">为什么需要面向服务的泛型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SOAP"><span class="toc-number">1.2.</span> <span class="toc-text">SOAP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#SOAP-%E5%8C%85%E7%BB%93%E6%9E%84"><span class="toc-number">1.2.1.</span> <span class="toc-text">SOAP 包结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.2.2.</span> <span class="toc-text">处理模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%84%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.3.</span> <span class="toc-text">处理模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%A4%E4%BA%92%E6%A8%A1%E5%BC%8F"><span class="toc-number">1.2.4.</span> <span class="toc-text">交互模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WSDL"><span class="toc-number">1.3.</span> <span class="toc-text">WSDL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#WSDL-%E7%9A%84%E6%A0%B8%E5%BF%83"><span class="toc-number">1.3.1.</span> <span class="toc-text">WSDL 的核心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B7%E4%BD%93%E9%83%A8%E4%BB%B6%E7%9A%84%E7%94%A8%E9%80%94"><span class="toc-number">1.3.2.</span> <span class="toc-text">具体部件的用途</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%B3%9B%E5%9E%8B"><span class="toc-number">1.4.</span> <span class="toc-text">服务的泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-VS-%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1"><span class="toc-number">1.4.1.</span> <span class="toc-text">面向对象 VS 面向服务</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E5%A4%A7%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99"><span class="toc-number">1.5.</span> <span class="toc-text">八大设计原则</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%87%E5%87%86%E5%8C%96%E6%9C%8D%E5%8A%A1%E5%90%88%E7%BA%A6"><span class="toc-number">1.5.1.</span> <span class="toc-text">标准化服务合约</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%9D%BE%E6%95%A3%E8%80%A6%E5%90%88"><span class="toc-number">1.5.2.</span> <span class="toc-text">服务松散耦合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%8A%BD%E8%B1%A1"><span class="toc-number">1.5.3.</span> <span class="toc-text">服务抽象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%AF%E5%A4%8D%E7%94%A8%E6%80%A7"><span class="toc-number">1.5.4.</span> <span class="toc-text">服务可复用性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E8%87%AA%E6%B2%BB"><span class="toc-number">1.5.5.</span> <span class="toc-text">服务自治</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%97%A0%E7%8A%B6%E6%80%81%E6%80%A7"><span class="toc-number">1.5.6.</span> <span class="toc-text">服务无状态性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%AF%E5%8F%91%E7%8E%B0%E6%80%A7"><span class="toc-number">1.5.7.</span> <span class="toc-text">服务可发现性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%8F%AF%E7%BB%84%E5%90%88%E6%80%A7"><span class="toc-number">1.5.8.</span> <span class="toc-text">服务可组合性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E9%A2%98"><span class="toc-number">2.</span> <span class="toc-text">综合题</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Web-Service"><span class="toc-number">2.1.</span> <span class="toc-text">Web Service</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%BB%BA%E6%A8%A1"><span class="toc-number">2.1.1.</span> <span class="toc-text">服务的建模</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%9A%84%E6%9F%A5%E8%AF%A2"><span class="toc-number">2.1.2.</span> <span class="toc-text">服务的查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">2.1.3.</span> <span class="toc-text">服务的调用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%88%86%E6%9E%90%E5%92%8C%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1"><span class="toc-number">2.2.</span> <span class="toc-text">服务分析和服务设计</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E5%88%86%E6%9E%90%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.1.</span> <span class="toc-text">服务分析流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E8%AE%BE%E8%AE%A1%E6%B5%81%E7%A8%8B"><span class="toc-number">2.2.2.</span> <span class="toc-text">服务设计流程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#schema-%E9%9B%86%E4%B8%AD%E5%8C%96"><span class="toc-number">2.2.3.</span> <span class="toc-text">schema 集中化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%88%E7%BA%A6%E9%9B%86%E4%B8%AD%E5%8C%96"><span class="toc-number">2.2.4.</span> <span class="toc-text">合约集中化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E9%9B%86%E4%B8%AD%E5%8C%96"><span class="toc-number">2.2.5.</span> <span class="toc-text">逻辑集中化</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2023/06/19/SOA%E5%A4%8D%E4%B9%A0/" title="SOA复习"><img src="/img/SAO.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="SOA复习"></a><div class="content"><a class="title" href="/2023/06/19/SOA%E5%A4%8D%E4%B9%A0/" title="SOA复习">SOA复习</a><time datetime="2023-06-19T08:00:00.000Z" title="发表于 2023-06-19 16:00:00">2023-06-19</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/08/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/" title="面向服务的软件工程复习"><img src="/img/flower.jpg" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="面向服务的软件工程复习"></a><div class="content"><a class="title" href="/2023/04/08/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%A4%8D%E4%B9%A0/" title="面向服务的软件工程复习">面向服务的软件工程复习</a><time datetime="2023-04-08T14:20:00.000Z" title="发表于 2023-04-08 22:20:00">2023-04-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/04/08/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%8D%E4%B9%A0/" title="服务端开发复习"><img src="/img/fuwu.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="服务端开发复习"></a><div class="content"><a class="title" href="/2023/04/08/%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%BC%80%E5%8F%91%E5%A4%8D%E4%B9%A0/" title="服务端开发复习">服务端开发复习</a><time datetime="2023-04-08T08:20:00.000Z" title="发表于 2023-04-08 16:20:00">2023-04-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2023/03/20/hello-myBlog/" title="Hello My Blog"><img src="/img/yinghua.png" onerror='this.onerror=null,this.src="/img/404.jpg"' alt="Hello My Blog"></a><div class="content"><a class="title" href="/2023/03/20/hello-myBlog/" title="Hello My Blog">Hello My Blog</a><time datetime="2023-03-20T12:00:00.000Z" title="发表于 2023-03-20 20:00:00">2023-03-20</time></div></div></div></div></div></div></main><footer id="footer" style="background-image:url('/img/flower.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023 By REHE</div><div class="framework-info"><span>框架</span> <a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题</span> <a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"></div><canvas class="fireworks" mobile="false"></canvas><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/fireworks.min.js"></script><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/metingjs/dist/Meting.min.js"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>